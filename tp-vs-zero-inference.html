<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TP vs ZeRO for Inference — Visual Deep Dive</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0a;
  --bg-card: #121212;
  --bg-card-hover: #1a1a1a;
  --bg-section-alt: #0f0f0f;
  --fg: #f2f2f2;
  --fg-muted: #a3a3a3;
  --border: #262626;
  --border-light: #333;
  --primary: #00d46a;
  --primary-dim: #00a854;
  --secondary: #00c8e6;
  --accent: #a78bfa;
  --red: #FF7043;
  --orange: #FF9800;
  --yellow: #FFCA28;
  --blue: #42A5F5;
  --green: #66BB6A;
  --pink: #F06292;
  --font-sans: 'Inter', system-ui, -apple-system, sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
  --font-serif: 'Instrument Serif', Georgia, serif;
  --max-w: 1280px;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; font-size: 16px; }
body {
  background: var(--bg); color: var(--fg); font-family: var(--font-sans);
  line-height: 1.7; -webkit-font-smoothing: antialiased; overflow-x: hidden;
}
a { color: var(--primary); text-decoration: none; }
a:hover { text-decoration: underline; }
code, pre { font-family: var(--font-mono); }
.container { max-width: var(--max-w); margin: 0 auto; padding: 0 24px; }
.gradient-text {
  background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
}

/* NAVBAR */
.navbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  background: rgba(10,10,10,0.85); backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px); border-bottom: 1px solid var(--border);
}
.nav-inner {
  max-width: var(--max-w); margin: 0 auto; padding: 12px 24px;
  display: flex; align-items: center; justify-content: space-between;
}
.nav-brand { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 1.1rem; }
.brand-tag {
  font-size: 0.7rem; background: var(--primary); color: #000;
  padding: 2px 8px; border-radius: 9999px; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.5px;
}
.nav-links { display: flex; gap: 20px; flex-wrap: wrap; }
.nav-links a { color: var(--fg-muted); font-size: 0.82rem; font-weight: 500; transition: color 0.2s; }
.nav-links a:hover { color: var(--primary); text-decoration: none; }

/* HERO */
.hero {
  position: relative; min-height: 100vh; display: flex;
  align-items: center; justify-content: center; text-align: center;
  padding: 120px 24px 80px; overflow: hidden;
}
.hero-bg-orbs { position: absolute; inset: 0; pointer-events: none; }
.orb { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.12; }
.orb-green { width: 500px; height: 500px; background: var(--primary); top: 10%; left: 10%; animation: float-slow 20s ease-in-out infinite; }
.orb-cyan { width: 400px; height: 400px; background: var(--secondary); top: 40%; right: 5%; animation: float-slow 25s ease-in-out infinite reverse; }
.orb-purple { width: 350px; height: 350px; background: var(--accent); bottom: 10%; left: 30%; animation: float-slow 22s ease-in-out infinite; }
@keyframes float-slow {
  0%, 100% { transform: translate(0, 0); }
  25% { transform: translate(30px, -20px); }
  50% { transform: translate(-20px, 30px); }
  75% { transform: translate(20px, 20px); }
}
.hero-content { position: relative; z-index: 1; max-width: 850px; }
.hero-badge {
  display: inline-flex; align-items: center; gap: 8px;
  background: rgba(0,212,106,0.1); border: 1px solid rgba(0,212,106,0.3);
  border-radius: 9999px; padding: 6px 18px; font-size: 0.82rem;
  font-weight: 500; color: var(--primary); margin-bottom: 24px;
}
.pulse-dot { width: 8px; height: 8px; background: var(--primary); border-radius: 50%; animation: pulse 2s ease-in-out infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.4); } }
.hero h1 { font-family: var(--font-serif); font-style: italic; font-size: clamp(2.5rem, 7vw, 4.5rem); font-weight: 400; line-height: 1.1; margin-bottom: 20px; }
.hero-subtitle { font-size: 1.15rem; color: var(--fg-muted); line-height: 1.7; max-width: 650px; margin: 0 auto 40px; }
.hero-cards { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
.hero-stat-card {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 20px 12px; transition: border-color 0.3s, transform 0.2s;
}
.hero-stat-card:hover { border-color: rgba(0,212,106,0.3); transform: translateY(-2px); }
.stat-number {
  font-size: 1.8rem; font-weight: 700;
  background: linear-gradient(135deg, var(--primary), var(--secondary));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
}
.stat-label { font-size: 0.78rem; color: var(--fg-muted); margin-top: 4px; }

/* SECTIONS */
.section { padding: 100px 0; position: relative; }
.section-dark { background: var(--bg-section-alt); }
.section-heading { text-align: center; margin-bottom: 60px; }
.section-label {
  display: inline-block; font-size: 0.78rem; font-weight: 600;
  text-transform: uppercase; letter-spacing: 1.5px; color: var(--primary); margin-bottom: 12px;
}
.section-heading h2 {
  font-family: var(--font-serif); font-style: italic;
  font-size: clamp(2rem, 4vw, 3rem); font-weight: 400; line-height: 1.2; margin-bottom: 16px;
}
.section-subtitle { color: var(--fg-muted); font-size: 1.05rem; max-width: 650px; margin: 0 auto; }

/* CARDS */
.card {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 16px;
  padding: 28px 24px; transition: border-color 0.3s, transform 0.2s;
}
.card:hover { border-color: rgba(0,212,106,0.3); transform: translateY(-3px); }
.card h3 { font-size: 1.15rem; font-weight: 600; margin-bottom: 8px; }
.card p, .card li { font-size: 0.88rem; color: var(--fg-muted); line-height: 1.6; }
.card code {
  background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;
  font-size: 0.82rem; color: var(--secondary);
}

/* GRIDS */
.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
.grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }
@media (max-width: 900px) { .grid-2, .grid-3 { grid-template-columns: 1fr; } }

/* EQUATION BOX */
.equation-box {
  background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 10px;
  padding: 18px 24px; margin: 16px 0; text-align: center;
  font-family: var(--font-mono); font-size: 0.92rem; color: var(--secondary); line-height: 2;
}
.equation-box .eq-label {
  display: block; font-family: var(--font-sans); font-size: 0.72rem;
  color: var(--fg-muted); text-transform: uppercase; letter-spacing: 1px;
  margin-bottom: 8px; font-weight: 600;
}
.equation-box .eq-highlight { color: var(--primary); font-weight: 600; }

/* CALLOUTS */
.callout { border-radius: 10px; padding: 16px 20px; font-size: 0.85rem; line-height: 1.6; margin: 16px 0; }
.callout-info { background: rgba(66,165,245,0.08); border: 1px solid rgba(66,165,245,0.2); color: var(--fg-muted); }
.callout-green { background: rgba(0,212,106,0.08); border: 1px solid rgba(0,212,106,0.2); color: var(--fg-muted); }
.callout-warn { background: rgba(255,112,67,0.08); border: 1px solid rgba(255,112,67,0.2); color: var(--fg-muted); }
.callout-purple { background: rgba(167,139,250,0.08); border: 1px solid rgba(167,139,250,0.2); color: var(--fg-muted); }
.callout strong { color: var(--fg); }
.callout code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-size: 0.78rem; color: var(--secondary); }

/* COMPARISON TABLE */
.comp-table-wrap { overflow-x: auto; border-radius: 12px; border: 1px solid var(--border); margin: 20px 0; }
.comp-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
.comp-table thead { background: #1a1a2e; }
.comp-table th {
  padding: 14px 16px; text-align: left; font-size: 0.75rem; font-weight: 600;
  text-transform: uppercase; letter-spacing: 0.5px; color: var(--fg-muted);
  border-bottom: 1px solid var(--border);
}
.comp-table td {
  padding: 12px 16px; border-bottom: 1px solid rgba(38,38,38,0.5);
  color: var(--fg-muted); font-size: 0.82rem;
}
.val-good { color: var(--primary) !important; font-weight: 600; }
.val-bad { color: var(--red) !important; font-weight: 600; }

/* PROMPT BOX */
.prompt-box {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 14px;
  padding: 20px 24px; max-width: 700px; margin: 0 auto 32px; font-size: 0.92rem;
  position: relative;
}
.prompt-box .prompt-label {
  font-size: 0.7rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;
  color: var(--accent); margin-bottom: 8px;
}
.prompt-text { color: var(--fg); line-height: 1.6; }
.prompt-text .cursor-blink {
  display: inline-block; width: 2px; height: 1.1em; background: var(--primary);
  vertical-align: text-bottom; animation: blink 1s step-end infinite;
}
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

/* TOKEN STREAM */
.token-stream {
  display: flex; flex-wrap: wrap; gap: 6px; justify-content: center;
  max-width: 700px; margin: 0 auto 20px; min-height: 44px;
}
.token {
  display: inline-flex; align-items: center; padding: 6px 14px;
  border-radius: 8px; font-family: var(--font-mono); font-size: 0.82rem;
  font-weight: 600; transition: all 0.3s;
}
.token-done { background: rgba(0,212,106,0.1); border: 1px solid rgba(0,212,106,0.3); color: var(--primary); }
.token-generating {
  background: rgba(0,200,230,0.1); border: 1px solid rgba(0,200,230,0.4); color: var(--secondary);
  animation: token-pulse 1.2s ease-in-out infinite;
}
.token-pending { background: rgba(255,255,255,0.03); border: 1px dashed var(--border); color: var(--fg-muted); opacity: 0.4; }
@keyframes token-pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(0,200,230,0.3); } 50% { box-shadow: 0 0 12px 4px rgba(0,200,230,0.15); } }

/* LIVE FORWARD PASS VISUAL */
.fwd-pass-box {
  background: rgba(0,0,0,0.25); border: 1px solid var(--border); border-radius: 14px;
  padding: 24px; margin: 20px 0; position: relative; overflow: hidden;
}
.fwd-pass-box h4 {
  font-size: 0.92rem; font-weight: 600; margin-bottom: 16px; display: flex;
  align-items: center; gap: 8px;
}
.fwd-pass-box h4 .badge {
  font-size: 0.65rem; padding: 3px 10px; border-radius: 9999px; font-weight: 700;
  text-transform: uppercase; letter-spacing: 0.5px;
}
.badge-red { background: rgba(255,112,67,0.15); color: var(--red); border: 1px solid rgba(255,112,67,0.3); }
.badge-green { background: rgba(0,212,106,0.15); color: var(--primary); border: 1px solid rgba(0,212,106,0.3); }

/* GPU row for forward pass */
.gpu-row {
  display: flex; gap: 8px; margin-bottom: 10px; align-items: stretch;
}
.gpu-chip {
  flex: 1; border-radius: 10px; padding: 10px 6px; text-align: center;
  font-size: 0.68rem; font-weight: 600; min-height: 54px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 2px; transition: all 0.4s; border: 2px solid;
}
.gpu-chip .gpu-name { font-weight: 700; font-size: 0.7rem; }
.gpu-chip .gpu-state { font-size: 0.6rem; opacity: 0.8; }

/* Layer pipeline */
.layer-pipeline {
  display: flex; flex-direction: column; gap: 4px; margin: 12px 0;
}
.layer-row {
  display: flex; align-items: center; gap: 4px; min-height: 32px;
}
.layer-label {
  width: 60px; font-size: 0.68rem; font-weight: 600; color: var(--fg-muted);
  text-align: right; padding-right: 8px; flex-shrink: 0;
}
.layer-blocks { display: flex; gap: 2px; flex: 1; }
.layer-block {
  height: 30px; border-radius: 5px; display: flex; align-items: center;
  justify-content: center; font-size: 0.58rem; font-weight: 700; color: #fff;
  transition: all 0.4s;
}
.lb-gather { background: var(--red); }
.lb-compute { background: var(--blue); }
.lb-allreduce { background: var(--primary); }
.lb-discard { background: rgba(255,255,255,0.04); color: var(--fg-muted); border: 1px dashed var(--border); }
.lb-idle { background: transparent; }
.lb-resident { background: rgba(167,139,250,0.12); border: 1px solid rgba(167,139,250,0.3); color: var(--accent); font-size: 0.7rem; }

.layer-legend {
  display: flex; flex-wrap: wrap; gap: 12px; margin-top: 12px; justify-content: center;
}
.layer-legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.7rem; color: var(--fg-muted); }
.ll-swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; }

/* DATA VOLUME ANNOTATION */
.data-annotation {
  display: flex; align-items: center; gap: 8px; margin: 8px 0;
  font-family: var(--font-mono); font-size: 0.78rem;
}
.data-pipe {
  flex: 1; height: 6px; border-radius: 3px; position: relative;
}
.data-pipe-fill {
  height: 100%; border-radius: 3px; transition: width 0.5s ease;
}
.data-amount { font-weight: 700; min-width: 80px; text-align: right; }

/* PLAYBACK CONTROLS */
.playback {
  display: flex; align-items: center; gap: 12px; justify-content: center;
  margin: 24px 0; flex-wrap: wrap;
}
.play-btn {
  padding: 10px 28px; border-radius: 10px; font-size: 0.88rem; font-weight: 700;
  border: 2px solid var(--primary); background: rgba(0,212,106,0.08); color: var(--primary);
  cursor: pointer; transition: all 0.2s; letter-spacing: 0.5px;
}
.play-btn:hover { background: rgba(0,212,106,0.18); transform: translateY(-1px); }
.play-btn:disabled { opacity: 0.4; cursor: default; transform: none; }
.play-btn.reset-btn { border-color: var(--border); color: var(--fg-muted); background: var(--bg-card); }
.play-btn.reset-btn:hover { border-color: var(--fg-muted); }

.step-counter {
  font-family: var(--font-mono); font-size: 0.85rem; color: var(--fg-muted);
  min-width: 120px; text-align: center;
}
.narration {
  text-align: center; font-size: 0.92rem; color: var(--secondary);
  min-height: 28px; margin: 12px 0; font-weight: 500; transition: opacity 0.3s;
}

/* SPEED COMPARISON */
.speed-compare {
  display: flex; gap: 24px; justify-content: center; flex-wrap: wrap; margin: 24px 0;
}
.speed-card {
  flex: 1; max-width: 340px; min-width: 260px; border-radius: 14px; padding: 20px;
  text-align: center; border: 2px solid;
}
.speed-card h4 { font-size: 1rem; margin-bottom: 4px; }
.speed-card .speed-time { font-family: var(--font-mono); font-size: 2rem; font-weight: 700; margin: 8px 0; }
.speed-card .speed-detail { font-size: 0.78rem; color: var(--fg-muted); }

/* INTERACTIVE SLIDER */
.slider-group {
  display: flex; align-items: center; gap: 16px; margin: 12px 0; flex-wrap: wrap;
}
.slider-group label { font-size: 0.85rem; font-weight: 500; min-width: 140px; }
.slider-group input[type="range"] { flex: 1; min-width: 200px; accent-color: var(--primary); height: 6px; cursor: pointer; }
.slider-val { font-family: var(--font-mono); font-size: 0.88rem; font-weight: 600; color: var(--primary); min-width: 80px; text-align: right; }

/* TAKEAWAY CARDS */
.takeaway-card {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 16px;
  padding: 28px 24px; position: relative; overflow: hidden;
}
.takeaway-card::before {
  content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px;
  background: linear-gradient(90deg, var(--primary), var(--secondary));
}
.takeaway-num {
  font-family: var(--font-mono); font-size: 2rem; font-weight: 700;
  color: rgba(0,212,106,0.15); position: absolute; top: 12px; right: 16px;
}
.takeaway-card h3 { font-size: 1rem; font-weight: 600; margin-bottom: 6px; }
.takeaway-card p { font-size: 0.85rem; color: var(--fg-muted); line-height: 1.6; }

/* NUMBER HIGHLIGHTS */
.num-green { color: var(--primary); font-weight: 700; font-family: var(--font-mono); }
.num-red { color: var(--red); font-weight: 700; font-family: var(--font-mono); }
.num-blue { color: var(--blue); font-weight: 700; font-family: var(--font-mono); }
.num-cyan { color: var(--secondary); font-weight: 700; font-family: var(--font-mono); }

/* FOOTER */
.footer { border-top: 1px solid var(--border); padding: 40px 0; text-align: center; }
.footer-inner { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.footer-brand { font-size: 1.1rem; font-weight: 600; }
.footer p { font-size: 0.85rem; color: var(--fg-muted); }
.footer-muted { font-size: 0.78rem !important; color: rgba(163,163,163,0.5) !important; }

/* ANIMATIONS */
.fade-in { opacity: 0; transform: translateY(20px); transition: opacity 0.6s ease, transform 0.6s ease; }
.fade-in.visible { opacity: 1; transform: translateY(0); }
.stagger-1 { transition-delay: 0.1s; } .stagger-2 { transition-delay: 0.2s; }
.stagger-3 { transition-delay: 0.3s; } .stagger-4 { transition-delay: 0.4s; }

/* RESPONSIVE */
@media (max-width: 768px) {
  .hero-cards { grid-template-columns: repeat(2, 1fr); }
  .nav-links { display: none; }
  .hero h1 { font-size: 2.2rem; }
  .section { padding: 60px 0; }
  .grid-2, .grid-3 { grid-template-columns: 1fr; }
  .gpu-row { flex-wrap: wrap; }
  .gpu-chip { min-width: 70px; }
}
::selection { background: rgba(0,212,106,0.3); color: #fff; }

/* WEIGHT LAYOUT DIAGRAM */
.weight-layout {
  display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin: 20px 0;
}
.wl-gpu {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 12px; min-width: 110px; text-align: center;
}
.wl-gpu .wl-title { font-size: 0.72rem; font-weight: 700; margin-bottom: 8px; }
.wl-bar { width: 50px; margin: 0 auto; border-radius: 6px; overflow: hidden; border: 1px solid var(--border); }
.wl-seg {
  height: 20px; display: flex; align-items: center; justify-content: center;
  font-size: 0.5rem; font-weight: 700; color: rgba(255,255,255,0.9);
}
.wl-caption { font-size: 0.62rem; color: var(--fg-muted); margin-top: 6px; }

/* SIDE-BY-SIDE TOKEN GEN ANIMATION */
.token-gen-container {
  background: rgba(0,0,0,0.2); border: 1px solid var(--border); border-radius: 16px;
  padding: 28px 24px; margin: 20px 0;
}
.tg-prompt-area {
  text-align: center; margin-bottom: 20px;
}
.tg-prompt {
  display: inline-block; background: var(--bg-card); border: 1px solid var(--accent);
  border-radius: 10px; padding: 10px 20px; font-size: 0.88rem; color: var(--fg);
}
.tg-prompt .tg-label {
  font-size: 0.65rem; font-weight: 700; color: var(--accent);
  text-transform: uppercase; letter-spacing: 1px; display: block; margin-bottom: 4px;
}
.tg-output-area {
  display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;
  margin-bottom: 20px; min-height: 40px;
}
.tg-token {
  padding: 5px 12px; border-radius: 6px; font-family: var(--font-mono);
  font-size: 0.78rem; font-weight: 600; transition: all 0.3s;
}
.tg-generated { background: rgba(0,212,106,0.1); border: 1px solid rgba(0,212,106,0.3); color: var(--primary); }
.tg-current { background: rgba(0,200,230,0.12); border: 1px solid rgba(0,200,230,0.4); color: var(--secondary); animation: token-pulse 1s ease-in-out infinite; }
.tg-future { background: rgba(255,255,255,0.02); border: 1px dashed rgba(255,255,255,0.08); color: rgba(255,255,255,0.15); }

/* DUAL PANEL */
.dual-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
@media (max-width: 900px) { .dual-panel { grid-template-columns: 1fr; } }

.panel {
  border-radius: 14px; padding: 20px; border: 2px solid;
}
.panel-zero { border-color: rgba(255,112,67,0.3); background: rgba(255,112,67,0.03); }
.panel-tp { border-color: rgba(0,212,106,0.3); background: rgba(0,212,106,0.03); }
.panel h4 {
  font-size: 0.92rem; font-weight: 700; margin-bottom: 12px;
  display: flex; align-items: center; gap: 8px;
}
.panel-zero h4 { color: var(--red); }
.panel-tp h4 { color: var(--primary); }

/* LAYER STEP BLOCKS */
.layer-steps { display: flex; flex-direction: column; gap: 6px; }
.ls-row { display: flex; align-items: center; gap: 6px; }
.ls-label { font-size: 0.68rem; font-weight: 600; color: var(--fg-muted); width: 55px; text-align: right; flex-shrink: 0; }
.ls-blocks { display: flex; gap: 2px; flex: 1; }
.ls-block {
  height: 26px; border-radius: 4px; display: flex; align-items: center;
  justify-content: center; font-size: 0.55rem; font-weight: 700; color: #fff;
  transition: all 0.4s ease;
}
.ls-gather { background: var(--red); }
.ls-compute { background: var(--blue); }
.ls-allreduce { background: var(--primary); }
.ls-discard { background: rgba(255,112,67,0.12); color: var(--red); border: 1px dashed rgba(255,112,67,0.3); }
.ls-ready { background: rgba(167,139,250,0.12); color: var(--accent); border: 1px solid rgba(167,139,250,0.25); }
.ls-dim { opacity: 0.15; }
.ls-active { box-shadow: 0 0 10px rgba(255,255,255,0.1); }

/* TIMER */
.timer-bar {
  margin-top: 12px; display: flex; align-items: center; gap: 8px;
}
.timer-track {
  flex: 1; height: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; overflow: hidden;
}
.timer-fill { height: 100%; border-radius: 4px; transition: width 0.4s ease; }
.timer-value { font-family: var(--font-mono); font-size: 0.78rem; font-weight: 700; min-width: 55px; text-align: right; }

/* ACCUMULATED COUNTER */
.accumulated-stat {
  display: flex; align-items: baseline; gap: 6px; margin-top: 8px;
  font-family: var(--font-mono); font-size: 0.75rem; color: var(--fg-muted);
}
.accumulated-stat .big-num { font-size: 1.1rem; font-weight: 700; }
</style>
</head>
<body>

<!-- NAVBAR -->
<nav class="navbar">
  <div class="nav-inner">
    <div class="nav-brand">
      <span style="font-size:1.3rem;">&#9889;</span>
      <span>ShallowSpeed</span>
      <span class="brand-tag">Inference</span>
    </div>
    <div class="nav-links">
      <a href="#prompt-arrives">Prompt Arrives</a>
      <a href="#how-weights-live">Weight Layout</a>
      <a href="#generating-tokens">Token Generation</a>
      <a href="#per-layer">Per-Layer Zoom</a>
      <a href="#calculator">Calculator</a>
      <a href="#takeaways">Takeaways</a>
    </div>
  </div>
</nav>

<!-- HERO -->
<section class="hero">
  <div class="hero-bg-orbs">
    <div class="orb orb-green"></div>
    <div class="orb orb-cyan"></div>
    <div class="orb orb-purple"></div>
  </div>
  <div class="hero-content">
    <div class="hero-badge"><div class="pulse-dot"></div> Distributed Inference</div>
    <h1>Why <span class="gradient-text">Tensor Parallelism</span> Beats <span class="gradient-text">ZeRO</span> at Inference</h1>
    <p class="hero-subtitle">
      A prompt comes in. Tokens must be generated one by one. Watch what happens
      inside the GPUs under each strategy — and why one is ~10,000&times; more efficient.
    </p>
    <div class="hero-cards">
      <div class="hero-stat-card fade-in stagger-1">
        <div class="stat-number">1 token</div>
        <div class="stat-label">Generated at a time during decoding</div>
      </div>
      <div class="hero-stat-card fade-in stagger-2">
        <div class="stat-number">80 layers</div>
        <div class="stat-label">Forward pass per token (Llama 70B)</div>
      </div>
      <div class="hero-stat-card fade-in stagger-3">
        <div class="stat-number">~200 MB</div>
        <div class="stat-label">ZeRO gathers per layer per token</div>
      </div>
      <div class="hero-stat-card fade-in stagger-4">
        <div class="stat-number">~16 KB</div>
        <div class="stat-label">TP all-reduces per layer per token</div>
      </div>
    </div>
  </div>
</section>

<!-- SECTION 1: A PROMPT ARRIVES -->
<section id="prompt-arrives" class="section">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Step 1</div>
      <h2><span class="gradient-text">A Prompt Arrives</span></h2>
      <p class="section-subtitle">
        A user sends a prompt. The model must generate a response, one token at a time.
        Each new token requires a complete forward pass through all 80 layers.
      </p>
    </div>

    <div class="prompt-box fade-in">
      <div class="prompt-label">User Prompt</div>
      <div class="prompt-text">"Explain how black holes form in simple terms."</div>
    </div>

    <div class="fade-in" style="text-align:center; margin-bottom: 24px;">
      <div style="font-size: 0.85rem; color: var(--fg-muted); margin-bottom: 16px;">
        The model generates the response <strong style="color:var(--fg)">one token at a time</strong>:
      </div>
      <div class="token-stream" id="hero-token-stream">
        <!-- Populated by JS -->
      </div>
      <div style="font-size: 0.78rem; color: var(--fg-muted); margin-top: 8px;">
        Each colored token = one full forward pass through <span class="num-cyan">all 80 layers</span>
      </div>
    </div>

    <div class="callout callout-info fade-in">
      <strong>The critical question:</strong> The model is spread across 8 GPUs. For every single token,
      every single layer needs the GPUs to coordinate. <em>How</em> they coordinate is what makes
      TP and ZeRO fundamentally different at inference time.
    </div>
  </div>
</section>

<!-- SECTION 2: HOW WEIGHTS LIVE ON GPUs -->
<section id="how-weights-live" class="section section-dark">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Step 2</div>
      <h2><span class="gradient-text">How the Weights Live on GPUs</span></h2>
      <p class="section-subtitle">
        Before any token is generated, the 70B model's weights must be distributed across
        the 8 GPUs. ZeRO and TP distribute them very differently.
      </p>
    </div>

    <div class="dual-panel fade-in">
      <!-- ZeRO layout -->
      <div class="panel panel-zero">
        <h4><span class="badge badge-red">ZeRO-3</span> Parameter Sharding</h4>
        <p style="font-size: 0.82rem; color: var(--fg-muted); margin-bottom: 16px;">
          Each GPU holds <strong style="color: var(--red);">1/8 of parameters</strong> — but these are <em>row shards</em>,
          so no GPU has a complete layer. To compute anything, a GPU must first collect shards from all other GPUs.
        </p>
        <div class="weight-layout" id="zero-weight-layout"></div>
        <div class="callout callout-warn" style="margin-top: 12px;">
          <strong>Problem:</strong> No single GPU can compute a layer on its own. It must all-gather
          the full weight matrix from 7 other GPUs first.
        </div>
      </div>

      <!-- TP layout -->
      <div class="panel panel-tp">
        <h4><span class="badge badge-green">TP</span> Column-Parallel Sharding</h4>
        <p style="font-size: 0.82rem; color: var(--fg-muted); margin-bottom: 16px;">
          Each GPU holds <strong style="color: var(--primary);">its column slice of EVERY layer</strong> — it can
          immediately compute a partial result for any layer without fetching anything.
        </p>
        <div class="weight-layout" id="tp-weight-layout"></div>
        <div class="callout callout-green" style="margin-top: 12px;">
          <strong>Advantage:</strong> Every GPU can start computing immediately.
          Only a tiny all-reduce on the output activation is needed to combine results.
        </div>
      </div>
    </div>
  </div>
</section>

<!-- SECTION 3: GENERATING TOKENS — THE MAIN EVENT -->
<section id="generating-tokens" class="section">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Step 3</div>
      <h2><span class="gradient-text">Generating Tokens</span> — The Main Event</h2>
      <p class="section-subtitle">
        Watch what happens inside the GPUs as each token is generated.
        Click play to step through the forward pass for each token.
      </p>
    </div>

    <div class="token-gen-container fade-in" id="main-animation">
      <!-- Prompt -->
      <div class="tg-prompt-area">
        <div class="tg-prompt">
          <span class="tg-label">Prompt</span>
          "Explain how black holes form..."
        </div>
      </div>

      <!-- Generated tokens -->
      <div style="text-align: center; font-size: 0.78rem; color: var(--fg-muted); margin-bottom: 8px;">Generated tokens:</div>
      <div class="tg-output-area" id="anim-tokens"></div>

      <!-- Narration -->
      <div class="narration" id="anim-narration">Press <strong>Play</strong> to start generating tokens</div>

      <!-- Side-by-side forward pass -->
      <div class="dual-panel" id="anim-panels">
        <!-- ZeRO side -->
        <div class="panel panel-zero">
          <h4><span class="badge badge-red">ZeRO-3</span> Forward Pass</h4>
          <div class="layer-steps" id="zero-layers"></div>
          <div class="timer-bar">
            <span style="font-size: 0.72rem; color: var(--fg-muted);">Comm time:</span>
            <div class="timer-track">
              <div class="timer-fill" id="zero-timer-fill" style="background: var(--red); width: 0%;"></div>
            </div>
            <span class="timer-value" id="zero-timer-val" style="color: var(--red);">0 ms</span>
          </div>
          <div class="accumulated-stat">
            Data moved: <span class="big-num" id="zero-data-moved" style="color: var(--red);">0 MB</span>
          </div>
        </div>

        <!-- TP side -->
        <div class="panel panel-tp">
          <h4><span class="badge badge-green">TP</span> Forward Pass</h4>
          <div class="layer-steps" id="tp-layers"></div>
          <div class="timer-bar">
            <span style="font-size: 0.72rem; color: var(--fg-muted);">Comm time:</span>
            <div class="timer-track">
              <div class="timer-fill" id="tp-timer-fill" style="background: var(--primary); width: 0%;"></div>
            </div>
            <span class="timer-value" id="tp-timer-val" style="color: var(--primary);">0 ms</span>
          </div>
          <div class="accumulated-stat">
            Data moved: <span class="big-num" id="tp-data-moved" style="color: var(--primary);">0 KB</span>
          </div>
        </div>
      </div>

      <!-- Controls -->
      <div class="playback">
        <button class="play-btn" id="btn-play" onclick="animPlay()">&#9654; Play</button>
        <button class="play-btn reset-btn" onclick="animReset()">Reset</button>
        <div class="step-counter" id="anim-step-counter">Token 0 / 8</div>
      </div>
    </div>

    <div class="callout callout-warn fade-in" style="margin-top: 16px;">
      <strong>Notice:</strong> For every single token, ZeRO-3 must all-gather ~200 MB of weights <em>per layer</em>.
      The red blocks (communication) completely dominate. Meanwhile, TP's green all-reduce blocks are
      so tiny they're barely visible — because they only move ~16 KB of activation data per layer.
    </div>
  </div>
</section>

<!-- SECTION 4: ZOOM INTO ONE LAYER -->
<section id="per-layer" class="section section-dark">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Step 4</div>
      <h2><span class="gradient-text">Zooming Into One Layer</span></h2>
      <p class="section-subtitle">
        Let's see exactly what each GPU does during a single transformer layer's forward pass,
        for a single token being decoded.
      </p>
    </div>

    <div class="dual-panel fade-in">
      <!-- ZeRO single layer -->
      <div class="panel panel-zero">
        <h4><span class="badge badge-red">ZeRO-3</span> One Layer, One Token</h4>
        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(255,112,67,0.2); border: 2px solid var(--red); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--red); flex-shrink: 0;">1</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">All-Gather weights</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Each GPU sends its 1/8 shard to all others. Every GPU reconstructs the full weight matrix.</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--red); margin-top: 2px;">~200 MB moved across network</div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(66,165,245,0.2); border: 2px solid var(--blue); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--blue); flex-shrink: 0;">2</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">Compute Y = W &times; x</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Multiply the (now-complete) weight matrix with the single token's hidden state.</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--blue); margin-top: 2px;">~few million FLOPs (tiny!)</div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(255,112,67,0.12); border: 2px dashed var(--red); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--red); flex-shrink: 0;">3</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">Discard gathered weights</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Free the memory — no room to keep them. Next layer will need its own all-gather.</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--red); margin-top: 2px;">Repeat for all 80 layers, for every token</div>
            </div>
          </div>
        </div>
        <!-- Time breakdown -->
        <div style="margin-top: 16px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px;">
          <div style="font-size: 0.72rem; font-weight: 600; color: var(--fg-muted); margin-bottom: 8px;">TIME BREAKDOWN (per layer)</div>
          <div style="display: flex; height: 24px; border-radius: 4px; overflow: hidden;">
            <div style="flex: 83; background: var(--red); display: flex; align-items: center; justify-content: center; font-size: 0.6rem; font-weight: 700; color: #fff;">All-Gather 83%</div>
            <div style="flex: 17; background: var(--blue); display: flex; align-items: center; justify-content: center; font-size: 0.6rem; font-weight: 700; color: #fff;">17%</div>
          </div>
        </div>
      </div>

      <!-- TP single layer -->
      <div class="panel panel-tp">
        <h4><span class="badge badge-green">TP</span> One Layer, One Token</h4>
        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(167,139,250,0.2); border: 2px solid var(--accent); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--accent); flex-shrink: 0;">1</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">Weights already resident!</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Each GPU's column shard for this layer is already in HBM. No fetching needed.</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--accent); margin-top: 2px;">0 bytes moved — weights are always hot</div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(66,165,245,0.2); border: 2px solid var(--blue); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--blue); flex-shrink: 0;">2</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">Compute Y_partial = W_shard &times; x</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Each GPU multiplies its column shard with the input. Gets a partial output vector.</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--blue); margin-top: 2px;">~few million FLOPs (same compute as ZeRO)</div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <div style="width: 30px; height: 30px; border-radius: 50%; background: rgba(0,212,106,0.2); border: 2px solid var(--primary); display: flex; align-items: center; justify-content: center; font-size: 0.72rem; font-weight: 800; color: var(--primary); flex-shrink: 0;">3</div>
            <div>
              <div style="font-size: 0.82rem; font-weight: 600; color: var(--fg);">All-Reduce to sum partials</div>
              <div style="font-size: 0.75rem; color: var(--fg-muted);">Sum the partial outputs across GPUs to get the full activation Y. Tiny data volume!</div>
              <div style="font-family: var(--font-mono); font-size: 0.75rem; color: var(--primary); margin-top: 2px;">~16 KB moved (8192 floats &times; 2 bytes)</div>
            </div>
          </div>
        </div>
        <!-- Time breakdown -->
        <div style="margin-top: 16px; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px;">
          <div style="font-size: 0.72rem; font-weight: 600; color: var(--fg-muted); margin-bottom: 8px;">TIME BREAKDOWN (per layer)</div>
          <div style="display: flex; height: 24px; border-radius: 4px; overflow: hidden;">
            <div style="flex: 95; background: var(--blue); display: flex; align-items: center; justify-content: center; font-size: 0.6rem; font-weight: 700; color: #fff;">Compute 95%</div>
            <div style="flex: 5; background: var(--primary); display: flex; align-items: center; justify-content: center; font-size: 0.6rem; font-weight: 700; color: #fff;">5%</div>
          </div>
        </div>
      </div>
    </div>

    <!-- The numbers derivation -->
    <div class="fade-in" style="margin-top: 40px;">
      <div class="grid-2">
        <div class="equation-box">
          <span class="eq-label">ZeRO-3: Data per layer (Llama 70B)</span>
          Weight matrix size: <span class="eq-highlight">d &times; d_ff = 8192 &times; 28672</span><br>
          &times; 2 bytes (fp16) &times; ~2 matrices = <span style="color: var(--red); font-weight: 700;">~200 MB</span><br>
          &times; 80 layers = <span style="color: var(--red); font-weight: 700;">~16 GB per token</span>
        </div>
        <div class="equation-box">
          <span class="eq-label">TP: Data per layer (Llama 70B)</span>
          Activation vector: <span class="eq-highlight">batch(1) &times; seq(1) &times; d_model(8192)</span><br>
          &times; 2 bytes (fp16) &times; 2 all-reduces = <span style="color: var(--primary); font-weight: 700;">~32 KB</span><br>
          &times; 80 layers = <span style="color: var(--primary); font-weight: 700;">~2.5 MB per token</span>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- SECTION 5: TOKEN AFTER TOKEN — THE COMPOUNDING COST -->
<section class="section">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Step 5</div>
      <h2><span class="gradient-text">Token After Token</span> — It Adds Up</h2>
      <p class="section-subtitle">
        A typical response is 200+ tokens. Each one pays the full communication cost.
        Drag the slider to see how total data transferred grows with response length.
      </p>
    </div>

    <div class="token-gen-container fade-in">
      <div class="slider-group">
        <label>Response tokens:</label>
        <input type="range" id="slider-tokens" min="1" max="512" step="1" value="100">
        <span class="slider-val" id="val-tokens">100</span>
      </div>
      <div class="slider-group">
        <label>Num layers:</label>
        <input type="range" id="slider-layers2" min="32" max="128" step="8" value="80">
        <span class="slider-val" id="val-layers2">80</span>
      </div>

      <div class="speed-compare" id="token-cost-cards">
        <!-- Filled by JS -->
      </div>

      <!-- Accumulated data bar -->
      <div style="margin-top: 16px;">
        <div style="font-size: 0.82rem; font-weight: 600; margin-bottom: 10px; text-align: center;">Total Data Moved to Generate Response</div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
          <span style="font-size: 0.78rem; color: var(--red); font-weight: 600; min-width: 60px;">ZeRO-3</span>
          <div style="flex: 1; height: 28px; background: rgba(255,255,255,0.03); border-radius: 6px; overflow: hidden; position: relative;">
            <div id="bar-zero-total" style="height: 100%; background: linear-gradient(90deg, var(--red), #FF5722); border-radius: 6px; transition: width 0.4s; display: flex; align-items: center; padding-left: 8px; font-size: 0.68rem; font-weight: 700; color: #fff;"></div>
          </div>
          <span id="label-zero-total" style="font-family: var(--font-mono); font-size: 0.82rem; color: var(--red); font-weight: 700; min-width: 80px; text-align: right;"></span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 0.78rem; color: var(--primary); font-weight: 600; min-width: 60px;">TP</span>
          <div style="flex: 1; height: 28px; background: rgba(255,255,255,0.03); border-radius: 6px; overflow: hidden; position: relative;">
            <div id="bar-tp-total" style="height: 100%; background: linear-gradient(90deg, var(--primary), var(--primary-dim)); border-radius: 6px; transition: width 0.4s; display: flex; align-items: center; padding-left: 8px; font-size: 0.68rem; font-weight: 700; color: #fff;"></div>
          </div>
          <span id="label-tp-total" style="font-family: var(--font-mono); font-size: 0.82rem; color: var(--primary); font-weight: 700; min-width: 80px; text-align: right;"></span>
        </div>
        <div style="text-align: center; margin-top: 12px; font-family: var(--font-mono); font-size: 1.1rem; font-weight: 700;">
          <span class="gradient-text" id="ratio-label">6,400&times; difference</span>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- SECTION 6: WHY ZERO IS FINE FOR TRAINING -->
<section class="section section-dark">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Context</div>
      <h2><span class="gradient-text">Why ZeRO Works Great for Training</span></h2>
      <p class="section-subtitle">
        ZeRO isn't a bad idea — the same all-gather that kills inference
        is barely noticeable during training. Here's why.
      </p>
    </div>

    <div class="grid-3 fade-in">
      <div class="card">
        <h3 style="font-size: 1rem;">Large Batches Amortize Cost</h3>
        <p>With batch=32, seq=2048, each layer does <code>2&times;32&times;2048&times;d&times;d_ff</code> FLOPs.
        The ~200 MB all-gather becomes a tiny fraction of total time.</p>
        <div style="margin-top: 12px; background: rgba(0,0,0,0.2); border-radius: 6px; padding: 10px;">
          <div style="display: flex; height: 18px; border-radius: 3px; overflow: hidden;">
            <div style="flex: 95; background: var(--blue); font-size: 0.55rem; color: #fff; display: flex; align-items: center; justify-content: center; font-weight: 700;">Compute 95%</div>
            <div style="flex: 5; background: var(--red); font-size: 0.55rem; color: #fff; display: flex; align-items: center; justify-content: center; font-weight: 700;">5%</div>
          </div>
          <div style="font-size: 0.65rem; color: var(--fg-muted); text-align: center; margin-top: 4px;">Training: comm is ~5% of time</div>
        </div>
      </div>
      <div class="card">
        <h3 style="font-size: 1rem;">Backward Pass Overlaps</h3>
        <p>During training, you also do backward passes. ZeRO can overlap next-layer's
        weight gather with current-layer's backward computation — hiding latency.</p>
      </div>
      <div class="card">
        <h3 style="font-size: 1rem;">Memory is the Bottleneck</h3>
        <p>ZeRO's real value is memory savings: each GPU stores only 1/N of parameters,
        gradients, and optimizer states. This lets you train models that can't fit on one GPU.</p>
      </div>
    </div>

    <div class="callout callout-info fade-in" style="margin-top: 20px;">
      <strong>The same ~200 MB all-gather</strong> that eats ~83% of per-layer time during single-token
      decoding only consumes ~5% during training. The communication cost is constant — only the
      compute changes. That's why strategy choice depends entirely on the workload.
    </div>
  </div>
</section>

<!-- SECTION 7: INTERACTIVE CALCULATOR -->
<section id="calculator" class="section">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Interactive</div>
      <h2><span class="gradient-text">Try It Yourself</span></h2>
      <p class="section-subtitle">
        Adjust model parameters to see how communication costs change for each strategy.
      </p>
    </div>

    <div class="token-gen-container fade-in">
      <div class="slider-group">
        <label>Hidden dim (d_model):</label>
        <input type="range" id="calc-d" min="2048" max="16384" step="1024" value="8192">
        <span class="slider-val" id="calc-d-val">8,192</span>
      </div>
      <div class="slider-group">
        <label>FFN dim (d_ff):</label>
        <input type="range" id="calc-dff" min="5504" max="53248" step="1024" value="28672">
        <span class="slider-val" id="calc-dff-val">28,672</span>
      </div>
      <div class="slider-group">
        <label>Num layers:</label>
        <input type="range" id="calc-layers" min="16" max="128" step="4" value="80">
        <span class="slider-val" id="calc-layers-val">80</span>
      </div>
      <div class="slider-group">
        <label>Num GPUs:</label>
        <input type="range" id="calc-gpus" min="2" max="16" step="2" value="8">
        <span class="slider-val" id="calc-gpus-val">8</span>
      </div>
      <div class="slider-group">
        <label>NVLink BW (GB/s):</label>
        <input type="range" id="calc-bw" min="100" max="900" step="50" value="600">
        <span class="slider-val" id="calc-bw-val">600</span>
      </div>

      <!-- Result comparison -->
      <div class="comp-table-wrap" style="margin-top: 24px;">
        <table class="comp-table" id="calc-table">
          <thead>
            <tr><th>Metric</th><th>ZeRO-3</th><th>Tensor Parallelism</th><th>Ratio</th></tr>
          </thead>
          <tbody id="calc-tbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<!-- SECTION 8: KEY TAKEAWAYS -->
<section id="takeaways" class="section section-dark">
  <div class="container">
    <div class="section-heading fade-in">
      <div class="section-label">Key Takeaways</div>
      <h2><span class="gradient-text">The Bottom Line</span></h2>
    </div>

    <div class="grid-3 fade-in">
      <div class="takeaway-card">
        <div class="takeaway-num">01</div>
        <h3>Every Token = Full Forward Pass</h3>
        <p>During autoregressive decoding, each new token triggers a complete walk through all layers.
        The parallelism strategy's communication cost is paid <em>per layer, per token</em>.</p>
      </div>
      <div class="takeaway-card">
        <div class="takeaway-num">02</div>
        <h3>ZeRO Moves Weights (~200 MB/layer)</h3>
        <p>ZeRO-3 must all-gather full weight matrices before each layer can compute.
        For a 70B model, that's ~16 GB of network traffic <em>per token</em>.</p>
      </div>
      <div class="takeaway-card">
        <div class="takeaway-num">03</div>
        <h3>TP Moves Activations (~16 KB/layer)</h3>
        <p>TP only all-reduces tiny activation vectors. Weights are always resident.
        Communication per token is ~2.5 MB — roughly 6,400&times; less than ZeRO-3.</p>
      </div>
      <div class="takeaway-card">
        <div class="takeaway-num">04</div>
        <h3>Compute is Tiny During Decoding</h3>
        <p>With batch=1, seq=1, the actual matmul per layer takes microseconds.
        ZeRO-3's all-gather takes milliseconds. Communication completely dominates.</p>
      </div>
      <div class="takeaway-card">
        <div class="takeaway-num">05</div>
        <h3>Training Amortizes the Cost</h3>
        <p>The same all-gather that's 83% of inference time is only 5% during training,
        because large batches create 65,000&times; more compute per layer.</p>
      </div>
      <div class="takeaway-card">
        <div class="takeaway-num">06</div>
        <h3>Production Uses TP for Inference</h3>
        <p>vLLM, TGI, TensorRT-LLM all use Tensor Parallelism within a node.
        ZeRO is reserved for training where memory savings justify the communication.</p>
      </div>
    </div>
  </div>
</section>

<!-- FOOTER -->
<footer class="footer">
  <div class="container">
    <div class="footer-inner">
      <div class="footer-brand">&#9889; ShallowSpeed</div>
      <p>TP vs ZeRO for Inference — Visual Deep Dive</p>
      <p class="footer-muted">Built with first principles, no external dependencies.</p>
    </div>
  </div>
</footer>

<script>
/* ========================================
   SCROLL REVEAL
   ======================================== */
const obs = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
}, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });
document.querySelectorAll('.fade-in').forEach(el => obs.observe(el));

/* ========================================
   HERO TOKEN STREAM
   ======================================== */
(function() {
  const tokens = ['When', 'a', 'massive', 'star', 'runs', 'out', 'of', 'fuel', ',', 'gravity', 'wins', '.'];
  const container = document.getElementById('hero-token-stream');
  tokens.forEach((t, i) => {
    const el = document.createElement('div');
    el.className = 'token token-done';
    el.textContent = t;
    el.style.animationDelay = (i * 0.15) + 's';
    container.appendChild(el);
  });
  // Add cursor token
  const cur = document.createElement('div');
  cur.className = 'token token-generating';
  cur.innerHTML = '...<span class="cursor-blink" style="margin-left:2px;"></span>';
  container.appendChild(cur);
})();

/* ========================================
   WEIGHT LAYOUT DIAGRAMS
   ======================================== */
(function() {
  // ZeRO layout
  const zeroContainer = document.getElementById('zero-weight-layout');
  let html = '';
  for (let g = 0; g < 4; g++) {
    html += `<div class="wl-gpu">
      <div class="wl-title" style="color: var(--red);">GPU ${g}</div>
      <div class="wl-bar" style="height: 120px; border-color: rgba(255,112,67,0.3);">`;
    for (let l = 0; l < 6; l++) {
      const isOwned = (l % 4 === g);
      html += `<div class="wl-seg" style="background: ${isOwned ? 'rgba(255,112,67,0.6)' : 'rgba(255,255,255,0.03)'}; border-bottom: 1px solid rgba(255,255,255,0.05);">
        ${isOwned ? 'L'+(l+1) : ''}
      </div>`;
    }
    html += `</div><div class="wl-caption">Only owns shards</div></div>`;
  }
  zeroContainer.innerHTML = html;

  // TP layout
  const tpContainer = document.getElementById('tp-weight-layout');
  html = '';
  for (let g = 0; g < 4; g++) {
    html += `<div class="wl-gpu">
      <div class="wl-title" style="color: var(--primary);">GPU ${g}</div>
      <div class="wl-bar" style="height: 120px; border-color: rgba(0,212,106,0.3);">`;
    for (let l = 0; l < 6; l++) {
      const shade = 0.25 + (l / 6) * 0.35;
      html += `<div class="wl-seg" style="background: rgba(0,212,106,${shade}); border-bottom: 1px solid rgba(255,255,255,0.05);">L${l+1}</div>`;
    }
    html += `</div><div class="wl-caption">Col ${g} of ALL layers</div></div>`;
  }
  tpContainer.innerHTML = html;
})();

/* ========================================
   MAIN TOKEN GENERATION ANIMATION
   ======================================== */
const ANIM_TOKENS = ['When', 'a', 'massive', 'star', 'runs', 'out', 'of', 'fuel'];
const ANIM_LAYERS_SHOWN = 6; // show 6 representative layers
const LAYER_LABELS = ['Layer 1', 'Layer 2', '...', 'Layer 39', 'Layer 40', '...', 'Layer 79', 'Layer 80'];
const DISPLAY_LAYERS = ['L1', 'L2', 'L20', 'L40', 'L60', 'L80'];

let animTokenIdx = 0;
let animLayerIdx = 0;
let animRunning = false;
let animInterval = null;

function initAnimLayers() {
  const zeroEl = document.getElementById('zero-layers');
  const tpEl = document.getElementById('tp-layers');
  let zh = '', th = '';
  for (let i = 0; i < DISPLAY_LAYERS.length; i++) {
    const label = DISPLAY_LAYERS[i];
    zh += `<div class="ls-row">
      <div class="ls-label">${label}</div>
      <div class="ls-blocks" id="zero-lb-${i}">
        <div class="ls-block ls-gather ls-dim" style="flex:5;" id="zero-gather-${i}">All-Gather</div>
        <div class="ls-block ls-compute ls-dim" style="flex:1;" id="zero-compute-${i}">Compute</div>
        <div class="ls-block ls-discard ls-dim" style="flex:0.8;" id="zero-discard-${i}">Discard</div>
      </div>
    </div>`;
    th += `<div class="ls-row">
      <div class="ls-label">${label}</div>
      <div class="ls-blocks" id="tp-lb-${i}">
        <div class="ls-block ls-ready ls-dim" style="flex:0.5;" id="tp-ready-${i}">&#10003;</div>
        <div class="ls-block ls-compute ls-dim" style="flex:4;" id="tp-compute-${i}">Compute</div>
        <div class="ls-block ls-allreduce ls-dim" style="flex:0.5;" id="tp-allreduce-${i}">AR</div>
      </div>
    </div>`;
  }
  zeroEl.innerHTML = zh;
  tpEl.innerHTML = th;
}

function renderTokens() {
  const el = document.getElementById('anim-tokens');
  let html = '';
  for (let i = 0; i < ANIM_TOKENS.length; i++) {
    if (i < animTokenIdx) {
      html += `<span class="tg-token tg-generated">${ANIM_TOKENS[i]}</span>`;
    } else if (i === animTokenIdx) {
      html += `<span class="tg-token tg-current">${ANIM_TOKENS[i]}</span>`;
    } else {
      html += `<span class="tg-token tg-future">${ANIM_TOKENS[i]}</span>`;
    }
  }
  el.innerHTML = html;
}

function resetLayerHighlights() {
  for (let i = 0; i < DISPLAY_LAYERS.length; i++) {
    // ZeRO
    document.getElementById('zero-gather-' + i).classList.add('ls-dim');
    document.getElementById('zero-gather-' + i).classList.remove('ls-active');
    document.getElementById('zero-compute-' + i).classList.add('ls-dim');
    document.getElementById('zero-compute-' + i).classList.remove('ls-active');
    document.getElementById('zero-discard-' + i).classList.add('ls-dim');
    document.getElementById('zero-discard-' + i).classList.remove('ls-active');
    // TP
    document.getElementById('tp-ready-' + i).classList.add('ls-dim');
    document.getElementById('tp-ready-' + i).classList.remove('ls-active');
    document.getElementById('tp-compute-' + i).classList.add('ls-dim');
    document.getElementById('tp-compute-' + i).classList.remove('ls-active');
    document.getElementById('tp-allreduce-' + i).classList.add('ls-dim');
    document.getElementById('tp-allreduce-' + i).classList.remove('ls-active');
  }
}

function highlightLayer(layerIdx, phase) {
  // phase: 0=gather/ready, 1=compute, 2=discard/allreduce
  if (layerIdx >= DISPLAY_LAYERS.length) return;

  // Light up completed layers
  for (let i = 0; i < layerIdx; i++) {
    ['zero-gather-', 'zero-compute-', 'zero-discard-'].forEach(p => {
      document.getElementById(p + i).classList.remove('ls-dim');
      document.getElementById(p + i).classList.remove('ls-active');
    });
    ['tp-ready-', 'tp-compute-', 'tp-allreduce-'].forEach(p => {
      document.getElementById(p + i).classList.remove('ls-dim');
      document.getElementById(p + i).classList.remove('ls-active');
    });
  }

  // Current layer phases
  const zeroPhases = ['zero-gather-', 'zero-compute-', 'zero-discard-'];
  const tpPhases = ['tp-ready-', 'tp-compute-', 'tp-allreduce-'];

  for (let p = 0; p <= phase; p++) {
    document.getElementById(zeroPhases[p] + layerIdx).classList.remove('ls-dim');
    document.getElementById(tpPhases[p] + layerIdx).classList.remove('ls-dim');
    if (p === phase) {
      document.getElementById(zeroPhases[p] + layerIdx).classList.add('ls-active');
      document.getElementById(tpPhases[p] + layerIdx).classList.add('ls-active');
    } else {
      document.getElementById(zeroPhases[p] + layerIdx).classList.remove('ls-active');
      document.getElementById(tpPhases[p] + layerIdx).classList.remove('ls-active');
    }
  }
}

const narrations = [
  ['All-Gather: Each GPU fetches ~200 MB of weights from others', 'Weights already in memory! Start computing immediately.'],
  ['Computing: multiply full weight matrix with token vector', 'Computing: multiply local column shard with token vector'],
  ['Discard: free the gathered weights. Move to next layer...', 'All-Reduce: sum partial outputs (~16 KB). Done with this layer!']
];

function animStep() {
  const phase = animLayerIdx % 3;
  const layer = Math.floor(animLayerIdx / 3);

  if (layer >= DISPLAY_LAYERS.length) {
    // Token complete — move to next token
    animLayerIdx = 0;
    animTokenIdx++;
    resetLayerHighlights();

    if (animTokenIdx >= ANIM_TOKENS.length) {
      // All done
      animStop();
      document.getElementById('anim-narration').innerHTML = '<strong style="color:var(--primary);">All tokens generated!</strong> Notice how ZeRO moved ~16 GB per token while TP moved ~2.5 MB.';
      document.getElementById('anim-step-counter').textContent = 'Done!';
      return;
    }
    renderTokens();
    // Update cumulative stats
    updateAnimStats();
    return;
  }

  highlightLayer(layer, phase);

  // Update narration
  const zeroNarr = narrations[phase][0];
  const tpNarr = narrations[phase][1];
  document.getElementById('anim-narration').innerHTML =
    `<span style="color:var(--red);">ZeRO:</span> ${zeroNarr} &nbsp;|&nbsp; <span style="color:var(--primary);">TP:</span> ${tpNarr}`;

  // Update timer/data
  const completedLayers = layer + (phase === 2 ? 1 : 0);
  const zeroDataMB = completedLayers * 200;
  const tpDataKB = completedLayers * 32;
  const zeroTimeMs = (zeroDataMB / (600 * 1000)) * 1000; // rough
  const tpTimeMs = (tpDataKB / (600 * 1000 * 1000)) * 1000;

  document.getElementById('zero-timer-fill').style.width = Math.min(100, (completedLayers / DISPLAY_LAYERS.length) * 100) + '%';
  document.getElementById('tp-timer-fill').style.width = Math.min(100, (completedLayers / DISPLAY_LAYERS.length) * 100) + '%';

  const totalZeroMB = (animTokenIdx * 80 * 200) + (completedLayers * 200);
  const totalTpKB = (animTokenIdx * 80 * 32) + (completedLayers * 32);
  document.getElementById('zero-data-moved').textContent = (totalZeroMB >= 1000 ? (totalZeroMB/1000).toFixed(1) + ' GB' : totalZeroMB + ' MB');
  document.getElementById('tp-data-moved').textContent = (totalTpKB >= 1000 ? (totalTpKB/1000).toFixed(1) + ' MB' : totalTpKB + ' KB');

  document.getElementById('zero-timer-val').textContent = ((completedLayers/80 * 27)).toFixed(1) + ' ms';
  document.getElementById('tp-timer-val').textContent = ((completedLayers/80 * 0.004)).toFixed(4) + ' ms';

  document.getElementById('anim-step-counter').textContent = `Token ${animTokenIdx + 1} / ${ANIM_TOKENS.length} — Layer ${DISPLAY_LAYERS[layer]}`;

  animLayerIdx++;
}

function updateAnimStats() {
  const totalZeroMB = animTokenIdx * 80 * 200;
  const totalTpKB = animTokenIdx * 80 * 32;
  document.getElementById('zero-data-moved').textContent = (totalZeroMB >= 1000 ? (totalZeroMB/1000).toFixed(1) + ' GB' : totalZeroMB + ' MB');
  document.getElementById('tp-data-moved').textContent = (totalTpKB >= 1000 ? (totalTpKB/1000).toFixed(1) + ' MB' : totalTpKB + ' KB');
}

function animPlay() {
  if (animRunning) {
    animStop();
    return;
  }
  animRunning = true;
  document.getElementById('btn-play').innerHTML = '&#10074;&#10074; Pause';
  animInterval = setInterval(animStep, 400);
}

function animStop() {
  animRunning = false;
  document.getElementById('btn-play').innerHTML = '&#9654; Play';
  if (animInterval) { clearInterval(animInterval); animInterval = null; }
}

function animReset() {
  animStop();
  animTokenIdx = 0;
  animLayerIdx = 0;
  resetLayerHighlights();
  renderTokens();
  document.getElementById('anim-narration').textContent = 'Press Play to start generating tokens';
  document.getElementById('anim-step-counter').textContent = 'Token 0 / ' + ANIM_TOKENS.length;
  document.getElementById('zero-timer-fill').style.width = '0%';
  document.getElementById('tp-timer-fill').style.width = '0%';
  document.getElementById('zero-timer-val').textContent = '0 ms';
  document.getElementById('tp-timer-val').textContent = '0 ms';
  document.getElementById('zero-data-moved').textContent = '0 MB';
  document.getElementById('tp-data-moved').textContent = '0 KB';
}

// Init
initAnimLayers();
renderTokens();

/* ========================================
   TOKEN COST SLIDER
   ======================================== */
function updateTokenCost() {
  const tokens = parseInt(document.getElementById('slider-tokens').value);
  const layers = parseInt(document.getElementById('slider-layers2').value);
  document.getElementById('val-tokens').textContent = tokens;
  document.getElementById('val-layers2').textContent = layers;

  const zeroPerTokenGB = (layers * 200) / 1000; // GB
  const tpPerTokenMB = (layers * 0.032); // MB (32 KB per layer)

  const zeroTotalGB = zeroPerTokenGB * tokens;
  const tpTotalMB = tpPerTokenMB * tokens;
  const tpTotalGB = tpTotalMB / 1000;

  const zeroTimeMs = (zeroPerTokenGB / 600) * 1000; // per token comm latency
  const tpTimeMs = (tpPerTokenMB / (600 * 1000)) * 1000; // per token

  const ratio = Math.round(zeroTotalGB / tpTotalGB);

  document.getElementById('token-cost-cards').innerHTML = `
    <div class="speed-card" style="border-color: rgba(255,112,67,0.3); background: rgba(255,112,67,0.03);">
      <h4 style="color: var(--red);">ZeRO-3</h4>
      <div class="speed-time" style="color: var(--red);">${zeroTotalGB.toFixed(1)} GB</div>
      <div class="speed-detail">total data moved for ${tokens} tokens</div>
      <div class="speed-detail" style="margin-top: 4px; color: var(--red);">${zeroPerTokenGB.toFixed(1)} GB/token &bull; ~${zeroTimeMs.toFixed(1)} ms comm/token</div>
    </div>
    <div class="speed-card" style="border-color: rgba(0,212,106,0.3); background: rgba(0,212,106,0.03);">
      <h4 style="color: var(--primary);">TP</h4>
      <div class="speed-time" style="color: var(--primary);">${tpTotalMB < 1000 ? tpTotalMB.toFixed(1) + ' MB' : tpTotalGB.toFixed(2) + ' GB'}</div>
      <div class="speed-detail">total data moved for ${tokens} tokens</div>
      <div class="speed-detail" style="margin-top: 4px; color: var(--primary);">${tpPerTokenMB.toFixed(1)} MB/token &bull; ~${(tpTimeMs * 1000).toFixed(1)} &micro;s comm/token</div>
    </div>
  `;

  // Bars
  document.getElementById('bar-zero-total').style.width = '100%';
  document.getElementById('bar-zero-total').textContent = zeroTotalGB.toFixed(1) + ' GB';
  const tpPct = Math.max(0.5, (tpTotalGB / zeroTotalGB) * 100);
  document.getElementById('bar-tp-total').style.width = tpPct + '%';
  document.getElementById('bar-tp-total').textContent = tpTotalMB < 1000 ? tpTotalMB.toFixed(0) + ' MB' : tpTotalGB.toFixed(2) + ' GB';
  document.getElementById('label-zero-total').textContent = zeroTotalGB.toFixed(1) + ' GB';
  document.getElementById('label-tp-total').textContent = tpTotalMB < 1000 ? tpTotalMB.toFixed(0) + ' MB' : tpTotalGB.toFixed(2) + ' GB';
  document.getElementById('ratio-label').textContent = ratio.toLocaleString() + '\u00D7 difference';
}

document.getElementById('slider-tokens').addEventListener('input', updateTokenCost);
document.getElementById('slider-layers2').addEventListener('input', updateTokenCost);
updateTokenCost();

/* ========================================
   INTERACTIVE CALCULATOR
   ======================================== */
function updateCalc() {
  const d = parseInt(document.getElementById('calc-d').value);
  const dff = parseInt(document.getElementById('calc-dff').value);
  const layers = parseInt(document.getElementById('calc-layers').value);
  const gpus = parseInt(document.getElementById('calc-gpus').value);
  const bw = parseInt(document.getElementById('calc-bw').value);

  document.getElementById('calc-d-val').textContent = d.toLocaleString();
  document.getElementById('calc-dff-val').textContent = dff.toLocaleString();
  document.getElementById('calc-layers-val').textContent = layers;
  document.getElementById('calc-gpus-val').textContent = gpus;
  document.getElementById('calc-bw-val').textContent = bw;

  // ZeRO: all-gather weights per layer
  const paramsPerLayer = (d * dff * 2) + (d * d * 2);
  const zeroPerLayerBytes = paramsPerLayer * 2;
  const zeroTotalBytes = zeroPerLayerBytes * layers;
  const zeroPerLayerMB = (zeroPerLayerBytes / (1024*1024)).toFixed(1);
  const zeroTotalGB = (zeroTotalBytes / (1024*1024*1024)).toFixed(2);
  const zeroTimeMs = ((zeroTotalBytes / (bw * 1e9)) * 1000).toFixed(2);

  // TP: all-reduce activations per layer
  const tpPerLayerBytes = 1 * 1 * d * 2 * 2; // batch=1, seq=1, d, fp16, 2 all-reduces
  const tpTotalBytes = tpPerLayerBytes * layers;
  const tpPerLayerKB = (tpPerLayerBytes / 1024).toFixed(1);
  const tpTotalMB = (tpTotalBytes / (1024*1024)).toFixed(3);
  const tpTimeUs = ((tpTotalBytes / (bw * 1e9)) * 1e6).toFixed(1);

  const ratio = Math.round(zeroTotalBytes / tpTotalBytes);

  document.getElementById('calc-tbody').innerHTML = `
    <tr><td>Data per layer</td><td class="val-bad">${zeroPerLayerMB} MB</td><td class="val-good">${tpPerLayerKB} KB</td><td>${Math.round(zeroPerLayerBytes / tpPerLayerBytes).toLocaleString()}&times;</td></tr>
    <tr><td>Total per token (${layers} layers)</td><td class="val-bad">${zeroTotalGB} GB</td><td class="val-good">${tpTotalMB} MB</td><td>${ratio.toLocaleString()}&times;</td></tr>
    <tr><td>Comm latency per token</td><td class="val-bad">${zeroTimeMs} ms</td><td class="val-good">${tpTimeUs} &micro;s</td><td>${Math.round(parseFloat(zeroTimeMs)*1000/parseFloat(tpTimeUs)).toLocaleString()}&times;</td></tr>
    <tr><td>What is communicated</td><td class="val-bad">Weight matrices</td><td class="val-good">Activation vectors</td><td>&mdash;</td></tr>
    <tr><td>Weights resident?</td><td class="val-bad">No (gather + discard)</td><td class="val-good">Yes (always hot)</td><td>&mdash;</td></tr>
  `;
}

['calc-d', 'calc-dff', 'calc-layers', 'calc-gpus', 'calc-bw'].forEach(id => {
  document.getElementById(id).addEventListener('input', updateCalc);
});
updateCalc();
</script>
</body>
</html>
